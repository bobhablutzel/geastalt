/*
 * Copyright (c) 2026 Bob Hablutzel. All rights reserved.
 *
 * Licensed under a dual-license model: freely available for non-commercial use;
 * commercial use requires a separate license. See LICENSE file for details.
 * Contact license@geastalt.com for commercial licensing.
 */

syntax = "proto3";

package com.geastalt.lock.grpc;

option java_multiple_files = true;
option java_package = "com.geastalt.lock.grpc.generated";
option java_outer_classname = "RegionServiceProto";

// Inter-region communication service for distributed lock coordination
service RegionService {
    // Request a vote from this region for a lock acquisition
    rpc RequestLockVote(LockVoteRequest) returns (LockVoteResponse);

    // Notify this region that a lock has been acquired (after quorum achieved)
    rpc NotifyLockAcquired(LockAcquiredNotification) returns (NotificationAck);

    // Notify this region that a lock has been released
    rpc NotifyLockReleased(LockReleasedNotification) returns (NotificationAck);

    // Heartbeat/health check between regions
    rpc Ping(PingRequest) returns (PingResponse);

    // Sync lock state (used for recovery and consistency)
    rpc SyncLockState(SyncLockStateRequest) returns (SyncLockStateResponse);
}

// Raft-related inter-node communication within a region cluster
service RaftService {
    // Request votes during leader election
    rpc RequestVote(RaftVoteRequest) returns (RaftVoteResponse);

    // Append entries (heartbeat and log replication)
    rpc AppendEntries(AppendEntriesRequest) returns (AppendEntriesResponse);
}

// --- Region Service Messages ---

message LockVoteRequest {
    // Unique identifier for the lock (GUID)
    string lock_id = 1;

    // Region requesting the lock
    string requesting_region = 2;

    // Client requesting the lock
    string client_id = 3;

    // Proposed lock timeout in milliseconds
    int64 proposed_timeout_ms = 4;

    // Proposed fencing token
    int64 proposed_fencing_token = 5;

    // Timestamp of the request (for ordering)
    int64 request_timestamp = 6;
}

message LockVoteResponse {
    // Whether this region grants the lock request
    bool granted = 1;

    // If not granted, the current holder information
    string current_holder_region = 2;
    string current_holder_client = 3;
    int64 current_fencing_token = 4;
    int64 current_expires_at = 5;

    // Region responding
    string responding_region = 6;

    // Reason for denial (if not granted)
    string denial_reason = 7;
}

message LockAcquiredNotification {
    // Unique identifier for the lock (GUID)
    string lock_id = 1;

    // Region that acquired the lock
    string holder_region = 2;

    // Client that acquired the lock
    string holder_client = 3;

    // Fencing token for this acquisition
    int64 fencing_token = 4;

    // When the lock expires
    int64 expires_at = 5;

    // Notifying region
    string notifying_region = 6;
}

message LockReleasedNotification {
    // Unique identifier for the lock (GUID)
    string lock_id = 1;

    // Fencing token that was released
    int64 fencing_token = 2;

    // Notifying region
    string notifying_region = 3;
}

message NotificationAck {
    // Whether the notification was processed successfully
    bool success = 1;

    // Region acknowledging
    string region_id = 2;
}

message PingRequest {
    // Region sending the ping
    string region_id = 1;

    // Timestamp of the ping
    int64 timestamp = 2;
}

message PingResponse {
    // Region responding
    string region_id = 1;

    // Whether this region is the leader of its cluster
    bool is_leader = 2;

    // Timestamp of the response
    int64 timestamp = 3;

    // Health status
    bool healthy = 4;
}

message SyncLockStateRequest {
    // Region requesting sync
    string requesting_region = 1;

    // Optional: only sync specific locks
    repeated string lock_ids = 2;
}

message SyncLockStateResponse {
    // All locks held by this region
    repeated LockState locks = 1;

    // Region responding
    string region_id = 2;
}

message LockState {
    string lock_id = 1;
    string holder_region = 2;
    string holder_client = 3;
    int64 fencing_token = 4;
    int64 expires_at = 5;
    int64 acquired_at = 6;
}

// --- Raft Service Messages ---

message RaftVoteRequest {
    // Candidate's term
    int64 term = 1;

    // Candidate requesting vote
    string candidate_id = 2;

    // Index of candidate's last log entry
    int64 last_log_index = 3;

    // Term of candidate's last log entry
    int64 last_log_term = 4;
}

message RaftVoteResponse {
    // Current term, for candidate to update itself
    int64 term = 1;

    // True if candidate received vote
    bool vote_granted = 2;

    // Node responding
    string voter_id = 3;
}

message AppendEntriesRequest {
    // Leader's term
    int64 term = 1;

    // Leader ID so follower can redirect clients
    string leader_id = 2;

    // Index of log entry immediately preceding new ones
    int64 prev_log_index = 3;

    // Term of prev_log_index entry
    int64 prev_log_term = 4;

    // Log entries to store (empty for heartbeat)
    repeated LogEntry entries = 5;

    // Leader's commit index
    int64 leader_commit = 6;
}

message AppendEntriesResponse {
    // Current term, for leader to update itself
    int64 term = 1;

    // True if follower contained entry matching prev_log_index and prev_log_term
    bool success = 2;

    // For optimization: the index of the last matching entry
    int64 match_index = 3;

    // Node responding
    string follower_id = 4;
}

message LogEntry {
    // Index of this entry
    int64 index = 1;

    // Term when entry was received
    int64 term = 2;

    // Type of command
    LogEntryType entry_type = 3;

    // Serialized command data
    bytes data = 4;
}

enum LogEntryType {
    LOG_ENTRY_TYPE_UNSPECIFIED = 0;
    LOG_ENTRY_TYPE_ACQUIRE_LOCK = 1;
    LOG_ENTRY_TYPE_RELEASE_LOCK = 2;
    LOG_ENTRY_TYPE_EXTEND_LOCK = 3;
    LOG_ENTRY_TYPE_NOOP = 4;
}
