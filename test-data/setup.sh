#!/usr/bin/env bash

# Copyright (c) 2026 Bob Hablutzel. All rights reserved.
#
# Licensed under a dual-license model: freely available for non-commercial use;
# commercial use requires a separate license. See LICENSE file for details.
# Contact license@geastalt.com for commercial licensing.

# ============================================================================
# Test Environment Setup Script
# ============================================================================
# Interactive menu-driven script for setting up the complete test environment:
#   - Configure database connection
#   - Initialize database schema
#   - Deploy services (Kubernetes or Docker)
#   - Load test data from CSV files
#   - Run gRPC load tests
#
# Usage: ./setup.sh
# ============================================================================

set -euo pipefail

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
ENV_FILE="$SCRIPT_DIR/.env"
LOG_FILE="$SCRIPT_DIR/setup.log"
K8S_NAMESPACE="geastalt"
ISTIO_GATEWAY_PORT="9080"

# ANSI colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# ---------------------------------------------------------------------------
# Logging
# ---------------------------------------------------------------------------
log() {
    local timestamp
    timestamp="$(date '+%Y-%m-%d %H:%M:%S')"
    echo "[$timestamp] $*" >> "$LOG_FILE"
}

info() {
    echo -e "${CYAN}[INFO]${NC} $*"
    log "INFO: $*"
}

success() {
    echo -e "${GREEN}[OK]${NC} $*"
    log "OK: $*"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $*"
    log "WARN: $*"
}

error() {
    echo -e "${RED}[ERROR]${NC} $*"
    log "ERROR: $*"
}

# ---------------------------------------------------------------------------
# Environment file management
# ---------------------------------------------------------------------------
load_env() {
    if [[ -f "$ENV_FILE" ]]; then
        # shellcheck disable=SC1090
        source "$ENV_FILE"
        return 0
    fi
    return 1
}

save_env() {
    cat > "$ENV_FILE" <<EOF
# Test environment configuration
# Generated by setup.sh on $(date)
DB_TYPE=${DB_TYPE:-postgresql}
DB_HOST=${DB_HOST:-192.168.1.17}
DB_PORT=${DB_PORT:-5432}
DB_NAME=${DB_NAME:-contact}
DB_USER=${DB_USER:-bob}
DB_PASSWORD=${DB_PASSWORD:-}
DEPLOY_MODE=${DEPLOY_MODE:-}
K8S_NAMESPACE=${K8S_NAMESPACE:-geastalt}
EOF
    chmod 600 "$ENV_FILE"
    success "Configuration saved to $ENV_FILE"
}

ensure_db_configured() {
    if ! load_env || [[ -z "${DB_TYPE:-}" ]]; then
        error "Database not configured. Run option 1 first."
        return 1
    fi
    return 0
}

# ---------------------------------------------------------------------------
# Tool checks
# ---------------------------------------------------------------------------
check_tool() {
    local tool="$1"
    if ! command -v "$tool" &>/dev/null; then
        error "Required tool not found: $tool"
        return 1
    fi
    return 0
}

check_db_tools() {
    case "${DB_TYPE:-}" in
        postgresql)
            check_tool psql
            ;;
        mysql)
            check_tool mysql
            ;;
        sqlserver)
            check_tool sqlcmd
            ;;
        *)
            error "Unknown database type: ${DB_TYPE:-}"
            return 1
            ;;
    esac
}

check_deploy_tools() {
    local mode="$1"
    case "$mode" in
        kubernetes)
            check_tool kubectl && check_tool helm && check_tool minikube
            ;;
        docker)
            check_tool docker
            ;;
        *)
            error "Unknown deploy mode: $mode"
            return 1
            ;;
    esac
}

# Wait for the Kubernetes API server to become responsive
# Istio installation adds many CRDs/pods and can temporarily overwhelm minikube
wait_for_apiserver() {
    local max_wait="${1:-60}"
    local waited=0
    while [[ $waited -lt $max_wait ]]; do
        if kubectl get nodes &>/dev/null; then
            return 0
        fi
        if [[ $waited -eq 0 ]]; then
            info "Waiting for Kubernetes API server to become responsive..."
        fi
        sleep 5
        ((waited += 5))
        printf "\r  Waiting... %ds / %ds" "$waited" "$max_wait"
    done
    echo ""
    error "Kubernetes API server not responsive after ${max_wait}s"
    return 1
}

# ---------------------------------------------------------------------------
# Database connectivity
# ---------------------------------------------------------------------------
test_db_connection() {
    info "Testing database connection..."
    case "$DB_TYPE" in
        postgresql)
            if PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "SELECT 1;" &>/dev/null; then
                success "PostgreSQL connection successful"
                return 0
            fi
            ;;
        mysql)
            if mysql -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" -e "SELECT 1;" &>/dev/null; then
                success "MySQL connection successful"
                return 0
            fi
            ;;
        sqlserver)
            if sqlcmd -S "$DB_HOST,$DB_PORT" -U "$DB_USER" -P "$DB_PASSWORD" -d "$DB_NAME" -Q "SELECT 1;" &>/dev/null; then
                success "SQL Server connection successful"
                return 0
            fi
            ;;
    esac
    error "Failed to connect to $DB_TYPE at $DB_HOST:$DB_PORT/$DB_NAME"
    return 1
}

# Test server connectivity without targeting a specific database
test_server_connection() {
    case "$DB_TYPE" in
        postgresql)
            PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "postgres" -c "SELECT 1;" &>/dev/null
            ;;
        mysql)
            mysql -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASSWORD" -e "SELECT 1;" &>/dev/null
            ;;
        sqlserver)
            sqlcmd -S "$DB_HOST,$DB_PORT" -U "$DB_USER" -P "$DB_PASSWORD" -d "master" -Q "SELECT 1;" &>/dev/null
            ;;
    esac
}

# Check whether the configured database exists on the server
database_exists() {
    case "$DB_TYPE" in
        postgresql)
            PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "postgres" -tAc \
                "SELECT 1 FROM pg_database WHERE datname='$DB_NAME';" 2>/dev/null | grep -q '1'
            ;;
        mysql)
            mysql -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASSWORD" -sNe \
                "SELECT 1 FROM information_schema.schemata WHERE schema_name='$DB_NAME';" 2>/dev/null | grep -q '1'
            ;;
        sqlserver)
            sqlcmd -S "$DB_HOST,$DB_PORT" -U "$DB_USER" -P "$DB_PASSWORD" -d "master" -h -1 -Q \
                "SET NOCOUNT ON; SELECT 1 FROM sys.databases WHERE name='$DB_NAME';" 2>/dev/null | grep -q '1'
            ;;
    esac
}

# Create the configured database
create_database() {
    info "Creating database '$DB_NAME'..."
    case "$DB_TYPE" in
        postgresql)
            PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "postgres" -c \
                "CREATE DATABASE \"$DB_NAME\";" 2>&1
            ;;
        mysql)
            mysql -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASSWORD" -e \
                "CREATE DATABASE \`$DB_NAME\`;" 2>&1
            ;;
        sqlserver)
            sqlcmd -S "$DB_HOST,$DB_PORT" -U "$DB_USER" -P "$DB_PASSWORD" -d "master" -Q \
                "CREATE DATABASE [$DB_NAME];" 2>&1
            ;;
    esac
}

check_table_exists() {
    local table="$1"
    case "$DB_TYPE" in
        postgresql)
            PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -tAc \
                "SELECT EXISTS(SELECT 1 FROM information_schema.tables WHERE table_name='$table');" 2>/dev/null | grep -q 't'
            ;;
        mysql)
            mysql -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" -sNe \
                "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema=DATABASE() AND table_name='$table';" 2>/dev/null | grep -q '[1-9]'
            ;;
        sqlserver)
            sqlcmd -S "$DB_HOST,$DB_PORT" -U "$DB_USER" -P "$DB_PASSWORD" -d "$DB_NAME" -h -1 -Q \
                "SET NOCOUNT ON; SELECT COUNT(*) FROM sys.tables WHERE name='$table';" 2>/dev/null | grep -q '[1-9]'
            ;;
    esac
}

get_row_count() {
    local table="$1"
    case "$DB_TYPE" in
        postgresql)
            PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -tAc \
                "SELECT COUNT(*) FROM $table;" 2>/dev/null
            ;;
        mysql)
            mysql -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" -sNe \
                "SELECT COUNT(*) FROM $table;" 2>/dev/null
            ;;
        sqlserver)
            sqlcmd -S "$DB_HOST,$DB_PORT" -U "$DB_USER" -P "$DB_PASSWORD" -d "$DB_NAME" -h -1 -Q \
                "SET NOCOUNT ON; SELECT COUNT(*) FROM $table;" 2>/dev/null | tr -d '[:space:]'
            ;;
    esac
}

# ---------------------------------------------------------------------------
# Option 1: Configure Database
# ---------------------------------------------------------------------------
configure_database() {
    echo ""
    echo -e "${BOLD}=== Configure Database ===${NC}"
    echo ""

    # Load existing config as defaults
    load_env 2>/dev/null || true

    echo "Select database type:"
    echo "  1) PostgreSQL"
    echo "  2) MySQL"
    echo "  3) SQL Server"
    echo ""
    local db_choice
    read -rp "Choice [1]: " db_choice
    db_choice="${db_choice:-1}"

    case "$db_choice" in
        1) DB_TYPE="postgresql"; local default_port=5432 ;;
        2) DB_TYPE="mysql";      local default_port=3306 ;;
        3) DB_TYPE="sqlserver";  local default_port=1433 ;;
        *)
            error "Invalid choice"
            return 1
            ;;
    esac

    read -rp "Host [${DB_HOST:-192.168.1.17}]: " input
    DB_HOST="${input:-${DB_HOST:-192.168.1.17}}"

    read -rp "Port [${DB_PORT:-$default_port}]: " input
    DB_PORT="${input:-${DB_PORT:-$default_port}}"

    read -rp "Database name [${DB_NAME:-contact}]: " input
    DB_NAME="${input:-${DB_NAME:-contact}}"

    read -rp "Username [${DB_USER:-bob}]: " input
    DB_USER="${input:-${DB_USER:-bob}}"

    read -rsp "Password [${DB_PASSWORD:+****}]: " input
    echo ""
    if [[ -n "$input" ]]; then
        DB_PASSWORD="$input"
    else
        DB_PASSWORD="${DB_PASSWORD:-}"
    fi

    echo ""
    info "Configuration:"
    echo "  Type:     $DB_TYPE"
    echo "  Host:     $DB_HOST"
    echo "  Port:     $DB_PORT"
    echo "  Database: $DB_NAME"
    echo "  Username: $DB_USER"
    echo ""

    if check_db_tools; then
        if test_db_connection; then
            save_env
        elif test_server_connection; then
            # Server is reachable but the target database isn't — check if it exists
            if database_exists; then
                error "Database '$DB_NAME' exists but connection failed — check permissions"
                return 1
            else
                warn "Server is reachable but database '$DB_NAME' does not exist"
                read -rp "Create database '$DB_NAME'? [Y/n]: " create_db
                if [[ "${create_db:-Y}" =~ ^[Yy] ]]; then
                    if create_database; then
                        success "Database '$DB_NAME' created"
                        save_env
                    else
                        error "Failed to create database — configuration not saved"
                        return 1
                    fi
                else
                    info "Database not created — configuration not saved"
                    return 1
                fi
            fi
        else
            error "Cannot reach $DB_TYPE server at $DB_HOST:$DB_PORT — check host, port, and credentials"
            return 1
        fi
    else
        warn "Database CLI tools not available — cannot verify connection, configuration not saved"
        return 1
    fi
}

# ---------------------------------------------------------------------------
# Option 2: Initialize Database Schema
# ---------------------------------------------------------------------------
initialize_schema() {
    echo ""
    echo -e "${BOLD}=== Initialize Database Schema ===${NC}"
    echo ""

    ensure_db_configured || return 1
    check_db_tools || return 1
    test_db_connection || return 1

    local sql_dir="$REPO_ROOT/contact/terraform/database/sql"
    local dialect_dir

    case "$DB_TYPE" in
        postgresql) dialect_dir="$sql_dir/postgresql" ;;
        mysql)      dialect_dir="$sql_dir/mysql" ;;
        sqlserver)  dialect_dir="$sql_dir/sqlserver" ;;
    esac

    if [[ ! -d "$dialect_dir" ]]; then
        error "DDL directory not found: $dialect_dir"
        return 1
    fi

    info "Applying DDL scripts from $dialect_dir"
    echo ""

    local script_count=0
    local error_count=0

    for script in "$dialect_dir"/*.sql; do
        local basename
        basename="$(basename "$script")"
        printf "  %-50s " "$basename"

        local result=0
        case "$DB_TYPE" in
            postgresql)
                PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" \
                    -f "$script" >> "$LOG_FILE" 2>&1 || result=1
                ;;
            mysql)
                mysql -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" \
                    < "$script" >> "$LOG_FILE" 2>&1 || result=1
                ;;
            sqlserver)
                sqlcmd -S "$DB_HOST,$DB_PORT" -U "$DB_USER" -P "$DB_PASSWORD" -d "$DB_NAME" \
                    -i "$script" >> "$LOG_FILE" 2>&1 || result=1
                ;;
        esac

        if [[ $result -eq 0 ]]; then
            echo -e "${GREEN}OK${NC}"
        else
            echo -e "${RED}FAILED${NC}"
            ((error_count++))
        fi
        ((script_count++))
    done

    echo ""
    if [[ $error_count -eq 0 ]]; then
        success "All $script_count DDL scripts applied successfully"
    else
        error "$error_count of $script_count scripts failed — check $LOG_FILE for details"
        return 1
    fi
}

# ---------------------------------------------------------------------------
# Option 3: Deploy Services
# ---------------------------------------------------------------------------
deploy_services() {
    echo ""
    echo -e "${BOLD}=== Deploy Services ===${NC}"
    echo ""

    echo "Select deployment mode:"
    echo "  1) Kubernetes (Helm + minikube)"
    echo "  2) Docker (docker compose)"
    echo ""
    local deploy_choice
    read -rp "Choice [1]: " deploy_choice
    deploy_choice="${deploy_choice:-1}"

    case "$deploy_choice" in
        1) deploy_kubernetes ;;
        2) deploy_docker ;;
        *)
            error "Invalid choice"
            return 1
            ;;
    esac
}

# ---------------------------------------------------------------------------
# Istio installation
# ---------------------------------------------------------------------------
install_istio() {
    info "Checking Istio installation..."

    # Check if istioctl is available
    if ! command -v istioctl &>/dev/null; then
        warn "istioctl not found — installing..."
        local istio_version="1.24.3"
        curl -L https://istio.io/downloadIstio | ISTIO_VERSION=$istio_version sh - 2>&1 | tail -3
        export PATH="$PWD/istio-$istio_version/bin:$PATH"
        if ! command -v istioctl &>/dev/null; then
            error "Failed to install istioctl"
            return 1
        fi
        success "istioctl installed (version $istio_version)"
    else
        success "istioctl found: $(istioctl version --short 2>/dev/null | head -1)"
    fi

    # Check if Istio is already installed on the cluster
    if istioctl verify-install &>/dev/null 2>&1; then
        success "Istio is already installed on the cluster"
    else
        info "Installing Istio with demo profile..."
        if istioctl install --set profile=demo -y 2>&1 | tee -a "$LOG_FILE"; then
            success "Istio installed successfully"
        else
            error "Istio installation failed"
            return 1
        fi
    fi

    # Create namespace if it doesn't exist
    info "Ensuring namespace $K8S_NAMESPACE exists..."
    kubectl create namespace "$K8S_NAMESPACE" --dry-run=client -o yaml | kubectl apply -f - >> "$LOG_FILE" 2>&1

    # Label namespace for sidecar injection
    info "Labeling namespace for Istio sidecar injection..."
    kubectl label namespace "$K8S_NAMESPACE" istio-injection=enabled --overwrite >> "$LOG_FILE" 2>&1
    success "Namespace $K8S_NAMESPACE labeled for Istio sidecar injection"

    # Wait for istio-system pods to be ready
    info "Waiting for Istio system pods to be ready..."
    kubectl wait --for=condition=Ready pods --all -n istio-system --timeout=120s 2>&1 | tail -3
    success "Istio system pods are ready"
}

deploy_kubernetes() {
    DEPLOY_MODE="kubernetes"
    load_env 2>/dev/null || true
    save_env

    check_deploy_tools kubernetes || return 1

    # Check minikube
    info "Checking minikube status..."
    if ! minikube status &>/dev/null; then
        warn "minikube is not running"
        read -rp "Start minikube? [Y/n]: " start_mk
        if [[ "${start_mk:-Y}" =~ ^[Yy] ]]; then
            info "Starting minikube..."
            minikube start
        else
            error "minikube required for Kubernetes deployment"
            return 1
        fi
    fi
    success "minikube is running"

    # Create namespace and install Istio
    info "Ensuring namespace $K8S_NAMESPACE exists..."
    kubectl create namespace "$K8S_NAMESPACE" --dry-run=client -o yaml | kubectl apply -f - >> "$LOG_FILE" 2>&1
    install_istio || warn "Istio setup had issues — continuing with deployment"

    # Wait for API server to stabilize after Istio installation
    wait_for_apiserver 90 || return 1

    # Set Docker env to minikube
    info "Configuring Docker environment for minikube..."
    eval "$(minikube docker-env)"

    # Build Docker images
    info "Building contact-api Docker image..."
    if docker build -t contact-api:latest -f "$REPO_ROOT/contact/contact-api/Dockerfile" "$REPO_ROOT/contact" >> "$LOG_FILE" 2>&1; then
        success "contact-api image built"
    else
        error "contact-api Docker build failed — check $LOG_FILE"
        return 1
    fi

    info "Building async-generate-ffpe-id Docker image..."
    if docker build -t async-generate-ffpe-id:latest -f "$REPO_ROOT/contact/async-generate-ffpe-id/Dockerfile" "$REPO_ROOT/contact" >> "$LOG_FILE" 2>&1; then
        success "async-generate-ffpe-id image built"
    else
        error "async-generate-ffpe-id Docker build failed — check $LOG_FILE"
        return 1
    fi

    info "Building address Docker image..."
    if docker build -t address:latest "$REPO_ROOT/address" >> "$LOG_FILE" 2>&1; then
        success "address image built"
    else
        error "address Docker build failed — check $LOG_FILE"
        return 1
    fi

    # Deploy Kafka if not running
    info "Checking Kafka deployment..."
    if ! kubectl get deployment kafka -n "$K8S_NAMESPACE" &>/dev/null; then
        info "Deploying Kafka..."
        kubectl apply -f "$REPO_ROOT/contact/k8s/kafka.yaml" -n "$K8S_NAMESPACE"
        info "Waiting for Kafka to be ready..."
        kubectl rollout status deployment/kafka -n "$K8S_NAMESPACE" --timeout=120s || warn "Kafka rollout timed out"
    else
        success "Kafka already deployed"
    fi

    # Check for required secrets
    info "Checking Kubernetes secrets..."
    local missing_secrets=()

    if ! kubectl get secret external-fpe-key-secret -n "$K8S_NAMESPACE" &>/dev/null; then
        missing_secrets+=("external-fpe-key-secret")
    fi
    if ! kubectl get secret async-generate-ffpe-id-secret -n "$K8S_NAMESPACE" &>/dev/null; then
        missing_secrets+=("async-generate-ffpe-id-secret")
    fi
    if ! kubectl get secret address-secret -n "$K8S_NAMESPACE" &>/dev/null; then
        missing_secrets+=("address-secret")
    fi

    if [[ ${#missing_secrets[@]} -gt 0 ]]; then
        warn "Missing Kubernetes secrets: ${missing_secrets[*]}"
        echo ""
        echo "Create them with:"
        for secret in "${missing_secrets[@]}"; do
            case "$secret" in
                external-fpe-key-secret)
                    echo "  kubectl create secret generic external-fpe-key-secret \\"
                    echo "    --from-literal=DB_PASSWORD=<password> \\"
                    echo "    --from-literal=USPS_CLIENT_ID=<id> \\"
                    echo "    --from-literal=USPS_CLIENT_SECRET=<secret> \\"
                    echo "    --from-literal=CONTACT_EXTERNAL_ID_KEY=<key>"
                    ;;
                async-generate-ffpe-id-secret)
                    echo "  kubectl create secret generic async-generate-ffpe-id-secret \\"
                    echo "    --from-literal=DB_PASSWORD=<password> \\"
                    echo "    --from-literal=CONTACT_EXTERNAL_ID_KEY=<key>"
                    ;;
                address-secret)
                    echo "  kubectl create secret generic address-secret \\"
                    echo "    --from-literal=DB_PASSWORD=<password> \\"
                    echo "    --from-literal=USPS_CLIENT_ID=<id> \\"
                    echo "    --from-literal=USPS_CLIENT_SECRET=<secret>"
                    ;;
            esac
            echo ""
        done

        read -rp "Continue deployment anyway? [y/N]: " cont
        if [[ ! "${cont:-N}" =~ ^[Yy] ]]; then
            return 1
        fi
    else
        success "All required secrets present"
    fi

    # Helm install/upgrade (use in-cluster Kafka since we deploy it inside K8s)
    local helm_errors=0

    info "Deploying contact-api via Helm..."
    if helm upgrade --install contact-api "$REPO_ROOT/contact/helm/contact-api" \
        --set kafka.bootstrapServers=kafka:9092 -n "$K8S_NAMESPACE" --create-namespace \
        --wait --timeout 180s >> "$LOG_FILE" 2>&1; then
        success "contact-api deployed"
    else
        error "contact-api helm deploy failed — check $LOG_FILE"
        ((helm_errors++))
    fi

    info "Deploying async-generate-ffpe-id via Helm..."
    if helm upgrade --install async-generate-ffpe-id "$REPO_ROOT/contact/helm/async-generate-ffpe-id" \
        -n "$K8S_NAMESPACE" --create-namespace --wait --timeout 180s >> "$LOG_FILE" 2>&1; then
        success "async-generate-ffpe-id deployed"
    else
        error "async-generate-ffpe-id helm deploy failed — check $LOG_FILE"
        ((helm_errors++))
    fi

    if [[ -d "$REPO_ROOT/contact/helm/contact-istio" ]]; then
        info "Deploying contact-istio via Helm..."
        if helm upgrade --install contact-istio "$REPO_ROOT/contact/helm/contact-istio" \
            -n "$K8S_NAMESPACE" --set service.namespace="$K8S_NAMESPACE" \
            --wait --timeout 60s >> "$LOG_FILE" 2>&1; then
            success "contact-istio deployed"
        else
            error "contact-istio helm deploy failed — check $LOG_FILE"
            ((helm_errors++))
        fi
    fi

    if [[ -d "$REPO_ROOT/address/helm/address" ]]; then
        info "Deploying address via Helm..."
        if helm upgrade --install address "$REPO_ROOT/address/helm/address" \
            -n "$K8S_NAMESPACE" --create-namespace --wait --timeout 120s >> "$LOG_FILE" 2>&1; then
            success "address deployed"
        else
            error "address helm deploy failed — check $LOG_FILE"
            ((helm_errors++))
        fi
    fi

    if [[ -d "$REPO_ROOT/address/helm/address-istio" ]]; then
        info "Deploying address-istio via Helm..."
        if helm upgrade --install address-istio "$REPO_ROOT/address/helm/address-istio" \
            -n "$K8S_NAMESPACE" --set service.namespace="$K8S_NAMESPACE" \
            --wait --timeout 60s >> "$LOG_FILE" 2>&1; then
            success "address-istio deployed"
        else
            error "address-istio helm deploy failed — check $LOG_FILE"
            ((helm_errors++))
        fi
    fi

    if [[ $helm_errors -gt 0 ]]; then
        error "$helm_errors helm deployment(s) failed"
        echo ""
        echo "  This often happens when the API server is overwhelmed after Istio installation."
        echo "  Wait a minute and retry option 3, or check: kubectl get pods -n $K8S_NAMESPACE"
        return 1
    fi

    # Wait for rollout (Hibernate ddl-auto may take a while with large datasets)
    info "Waiting for deployments to be ready..."
    kubectl rollout status deployment/contact-api -n "$K8S_NAMESPACE" --timeout=300s || {
        warn "contact-api rollout timed out"
    }

    # Restart deployments so pods pick up Istio sidecars
    info "Restarting deployments to inject Istio sidecars..."
    kubectl rollout restart deployment/contact-api -n "$K8S_NAMESPACE" >> "$LOG_FILE" 2>&1 || true
    kubectl rollout restart deployment/async-generate-ffpe-id -n "$K8S_NAMESPACE" >> "$LOG_FILE" 2>&1 || true
    kubectl rollout restart deployment/address -n "$K8S_NAMESPACE" >> "$LOG_FILE" 2>&1 || true
    info "Waiting for pods to be ready with sidecars..."
    kubectl rollout status deployment/contact-api -n "$K8S_NAMESPACE" --timeout=300s || {
        warn "contact-api rollout timed out after sidecar restart"
    }

    # Set up port-forwards for gRPC access
    echo ""
    wait_for_apiserver 60 || true

    if kubectl get svc istio-ingressgateway -n istio-system &>/dev/null; then
        info "Setting up port-forward to Istio ingress gateway (localhost:$ISTIO_GATEWAY_PORT → load-balanced)..."
        pkill -f "kubectl port-forward.*istio-ingressgateway.*$ISTIO_GATEWAY_PORT" 2>/dev/null || true
        kubectl port-forward svc/istio-ingressgateway -n istio-system "$ISTIO_GATEWAY_PORT":80 &>/dev/null &
        local gw_pid=$!
        sleep 3

        if kill -0 "$gw_pid" 2>/dev/null; then
            success "Ingress gateway port-forward active (PID $gw_pid) — gRPC at localhost:$ISTIO_GATEWAY_PORT (round-robin across all pods)"
            echo ""
            echo "  Use this for load-balanced gRPC access:"
            echo "    grpcurl -plaintext localhost:$ISTIO_GATEWAY_PORT list"
            echo ""
            echo "  For load testing (option 5), use:"
            echo "    Host: localhost   Port: $ISTIO_GATEWAY_PORT"
        else
            warn "Ingress gateway port-forward failed — you may need to run:"
            echo "    kubectl port-forward svc/istio-ingressgateway -n istio-system $ISTIO_GATEWAY_PORT:80 &"
        fi
    else
        warn "Istio ingress gateway not found — skipping gateway port-forward"
    fi

    # Also set up direct pod port-forward as a fallback
    info "Setting up port-forward for direct pod access (localhost:9001)..."
    pkill -f "kubectl port-forward.*contact-api.*9001" 2>/dev/null || true
    kubectl port-forward service/contact-api 9001:9001 -n "$K8S_NAMESPACE" &>/dev/null &
    local pf_pid=$!
    sleep 2

    if kill -0 "$pf_pid" 2>/dev/null; then
        success "Port-forward active (PID $pf_pid) — gRPC at localhost:9001 (single-pod, no load balancing)"
    else
        warn "Port-forward failed — you may need to run: kubectl port-forward service/contact-api 9001:9001 -n $K8S_NAMESPACE"
    fi
}

deploy_docker() {
    DEPLOY_MODE="docker"
    load_env 2>/dev/null || true
    save_env

    check_tool docker || return 1

    local compose_file="$SCRIPT_DIR/docker-compose.yml"
    if [[ ! -f "$compose_file" ]]; then
        error "Docker Compose file not found: $compose_file"
        return 1
    fi

    # Build images
    info "Building and starting services via Docker Compose..."
    docker compose -f "$compose_file" --env-file "$ENV_FILE" up -d --build 2>&1 | tee -a "$LOG_FILE"

    echo ""
    info "Waiting for services to become healthy..."

    local max_wait=180
    local waited=0
    local all_healthy=false

    while [[ $waited -lt $max_wait ]]; do
        local unhealthy
        unhealthy=$(docker compose -f "$compose_file" ps --format json 2>/dev/null | \
            grep -c '"Health":"starting"\|"Health":""' || true)

        if [[ "$unhealthy" -eq 0 ]]; then
            all_healthy=true
            break
        fi

        printf "\r  Waiting... %ds / %ds" "$waited" "$max_wait"
        sleep 5
        ((waited += 5))
    done
    echo ""

    if $all_healthy; then
        success "All services are healthy"
    else
        warn "Some services may not be healthy — check: docker compose -f $compose_file ps"
    fi

    echo ""
    docker compose -f "$compose_file" ps
    echo ""
    success "gRPC available at localhost:9001"
}

# ---------------------------------------------------------------------------
# Option 7: Create Kubernetes Secrets
# ---------------------------------------------------------------------------
create_k8s_secrets() {
    echo ""
    echo -e "${BOLD}=== Create Kubernetes Secrets ===${NC}"
    echo ""

    check_tool kubectl || return 1

    # Verify cluster access
    if ! kubectl cluster-info &>/dev/null; then
        error "Cannot reach Kubernetes cluster — is minikube running?"
        return 1
    fi
    success "Kubernetes cluster is reachable"
    echo ""

    # Collect credentials
    load_env 2>/dev/null || true
    local db_password="" usps_client_id="" usps_client_secret="" external_id_key=""

    # DB password — offer to reuse from .env if available
    if [[ -n "${DB_PASSWORD:-}" ]]; then
        echo -e "  ${CYAN}Database password found in .env${NC}"
        read -rp "Use the configured database password for all secrets? [Y/n]: " reuse_pw
        if [[ "${reuse_pw:-Y}" =~ ^[Yy] ]]; then
            db_password="$DB_PASSWORD"
        fi
    fi
    if [[ -z "$db_password" ]]; then
        read -rsp "Database password (DB_PASSWORD): " db_password
        stty echo
        echo ""
        if [[ -z "$db_password" ]]; then
            error "Database password is required"
            return 1
        fi
    fi

    # USPS credentials (shared by contact-api and address)
    echo ""
    read -rp "USPS Client ID (USPS_CLIENT_ID): " usps_client_id
    if [[ -z "$usps_client_id" ]]; then
        error "USPS Client ID is required"
        return 1
    fi

    read -rsp "USPS Client Secret (USPS_CLIENT_SECRET): " usps_client_secret
    stty echo
    echo ""
    if [[ -z "$usps_client_secret" ]]; then
        error "USPS Client Secret is required"
        return 1
    fi

    # External ID key (async-generate-ffpe-id only)
    echo ""
    read -rsp "Contact External ID Key (CONTACT_EXTERNAL_ID_KEY): " external_id_key
    stty echo
    echo ""
    if [[ -z "$external_id_key" ]]; then
        error "Contact External ID Key is required"
        return 1
    fi

    echo ""
    info "Secrets to create:"
    echo "  external-fpe-key-secret       DB_PASSWORD, USPS_CLIENT_ID, USPS_CLIENT_SECRET, CONTACT_EXTERNAL_ID_KEY"
    echo "  async-generate-ffpe-id-secret   DB_PASSWORD, CONTACT_EXTERNAL_ID_KEY"
    echo "  address-secret                DB_PASSWORD, USPS_CLIENT_ID, USPS_CLIENT_SECRET"
    echo ""

    # Ensure namespace exists
    info "Ensuring namespace $K8S_NAMESPACE exists..."
    kubectl create namespace "$K8S_NAMESPACE" --dry-run=client -o yaml | kubectl apply -f - >> "$LOG_FILE" 2>&1

    # Check for existing secrets and warn
    local existing=()
    for secret in external-fpe-key-secret async-generate-ffpe-id-secret address-secret; do
        if kubectl get secret "$secret" -n "$K8S_NAMESPACE" &>/dev/null; then
            existing+=("$secret")
        fi
    done

    if [[ ${#existing[@]} -gt 0 ]]; then
        warn "These secrets already exist and will be replaced: ${existing[*]}"
        read -rp "Continue? [y/N]: " confirm
        if [[ ! "${confirm:-N}" =~ ^[Yy] ]]; then
            info "Cancelled"
            return 0
        fi
        echo ""
        for secret in "${existing[@]}"; do
            kubectl delete secret "$secret" -n "$K8S_NAMESPACE" >> "$LOG_FILE" 2>&1
        done
    fi

    # Create external-fpe-key-secret (contact-api)
    info "Creating external-fpe-key-secret..."
    if kubectl create secret generic external-fpe-key-secret -n "$K8S_NAMESPACE" \
        --from-literal=DB_PASSWORD="$db_password" \
        --from-literal=USPS_CLIENT_ID="$usps_client_id" \
        --from-literal=USPS_CLIENT_SECRET="$usps_client_secret" \
        --from-literal=CONTACT_EXTERNAL_ID_KEY="$external_id_key" >> "$LOG_FILE" 2>&1; then
        success "external-fpe-key-secret created"
    else
        error "Failed to create external-fpe-key-secret"
        return 1
    fi

    # Create async-generate-ffpe-id-secret
    info "Creating async-generate-ffpe-id-secret..."
    if kubectl create secret generic async-generate-ffpe-id-secret -n "$K8S_NAMESPACE" \
        --from-literal=DB_PASSWORD="$db_password" \
        --from-literal=CONTACT_EXTERNAL_ID_KEY="$external_id_key" >> "$LOG_FILE" 2>&1; then
        success "async-generate-ffpe-id-secret created"
    else
        error "Failed to create async-generate-ffpe-id-secret"
        return 1
    fi

    # Create address-secret
    info "Creating address-secret..."
    if kubectl create secret generic address-secret -n "$K8S_NAMESPACE" \
        --from-literal=DB_PASSWORD="$db_password" \
        --from-literal=USPS_CLIENT_ID="$usps_client_id" \
        --from-literal=USPS_CLIENT_SECRET="$usps_client_secret" >> "$LOG_FILE" 2>&1; then
        success "address-secret created"
    else
        error "Failed to create address-secret"
        return 1
    fi

    echo ""
    success "All Kubernetes secrets created"
}

# ---------------------------------------------------------------------------
# Option 8: Install/Configure Istio
# ---------------------------------------------------------------------------
install_configure_istio() {
    echo ""
    echo -e "${BOLD}=== Install/Configure Istio ===${NC}"
    echo ""

    check_tool kubectl || return 1
    check_tool helm || return 1

    # Verify cluster access
    if ! kubectl cluster-info &>/dev/null; then
        error "Cannot reach Kubernetes cluster — is minikube running?"
        return 1
    fi
    success "Kubernetes cluster is reachable"
    echo ""

    # Install Istio
    install_istio || return 1

    # Wait for API server to stabilize after Istio installation
    wait_for_apiserver 90 || return 1
    echo ""

    # Deploy Istio Helm charts
    if [[ -d "$REPO_ROOT/contact/helm/contact-istio" ]]; then
        info "Deploying contact-istio via Helm..."
        if helm upgrade --install contact-istio "$REPO_ROOT/contact/helm/contact-istio" \
            -n "$K8S_NAMESPACE" --set service.namespace="$K8S_NAMESPACE" \
            --wait --timeout 60s >> "$LOG_FILE" 2>&1; then
            success "contact-istio deployed"
        else
            error "contact-istio helm deploy failed — check $LOG_FILE"
            return 1
        fi
    fi

    if [[ -d "$REPO_ROOT/address/helm/address-istio" ]]; then
        info "Deploying address-istio via Helm..."
        if helm upgrade --install address-istio "$REPO_ROOT/address/helm/address-istio" \
            -n "$K8S_NAMESPACE" --set service.namespace="$K8S_NAMESPACE" \
            --wait --timeout 60s >> "$LOG_FILE" 2>&1; then
            success "address-istio deployed"
        else
            error "address-istio helm deploy failed — check $LOG_FILE"
            return 1
        fi
    fi

    # Restart deployments to inject sidecars
    echo ""
    info "Restarting deployments to inject Istio sidecars..."
    local deployments=()
    for dep in contact-api async-generate-ffpe-id address; do
        if kubectl get deployment "$dep" -n "$K8S_NAMESPACE" &>/dev/null; then
            deployments+=("$dep")
            kubectl rollout restart deployment/"$dep" -n "$K8S_NAMESPACE" >> "$LOG_FILE" 2>&1
        fi
    done

    if [[ ${#deployments[@]} -gt 0 ]]; then
        info "Waiting for deployments to be ready with sidecars..."
        for dep in "${deployments[@]}"; do
            kubectl rollout status deployment/"$dep" -n "$K8S_NAMESPACE" --timeout=300s 2>/dev/null || \
                warn "$dep rollout timed out"
        done
    fi

    # Verify sidecar injection
    echo ""
    info "Verifying sidecar injection..."
    local pods_ready
    pods_ready=$(kubectl get pods -n "$K8S_NAMESPACE" --no-headers 2>/dev/null || true)
    if [[ -n "$pods_ready" ]]; then
        echo ""
        echo "  Pod status (2/2 = sidecar injected):"
        kubectl get pods -n "$K8S_NAMESPACE" --no-headers 2>/dev/null | while IFS= read -r line; do
            echo "    $line"
        done
    fi

    # Port-forward to Istio ingress gateway for load-balanced access
    echo ""
    info "Setting up port-forward to Istio ingress gateway (localhost:$ISTIO_GATEWAY_PORT)..."
    pkill -f "kubectl port-forward.*istio-ingressgateway.*$ISTIO_GATEWAY_PORT" 2>/dev/null || true
    kubectl port-forward svc/istio-ingressgateway -n istio-system "$ISTIO_GATEWAY_PORT":80 &>/dev/null &
    local gw_pid=$!
    sleep 2

    echo ""
    if kill -0 "$gw_pid" 2>/dev/null; then
        success "Ingress gateway port-forward active (PID $gw_pid) — gRPC at localhost:$ISTIO_GATEWAY_PORT"
        echo ""
        echo "  Test with:  grpcurl -plaintext localhost:$ISTIO_GATEWAY_PORT list"
        echo "  Load test:  use host=localhost port=$ISTIO_GATEWAY_PORT in option 5"
    else
        warn "Ingress gateway port-forward failed"
        echo "  Try manually: kubectl port-forward svc/istio-ingressgateway -n istio-system $ISTIO_GATEWAY_PORT:80"
    fi

    echo ""
    success "Istio setup complete"
}

# ---------------------------------------------------------------------------
# Option 4: Load Test Data
# ---------------------------------------------------------------------------
load_test_data() {
    echo ""
    echo -e "${BOLD}=== Load Test Data ===${NC}"
    echo ""

    ensure_db_configured || return 1
    check_db_tools || return 1
    test_db_connection || return 1

    # Check schema exists
    if ! check_table_exists "contacts"; then
        error "Schema not initialized — run option 2 first"
        return 1
    fi

    # Check CSV files exist
    local csv_files=("contacts.csv" "addresses.csv" "companies_and_contracts.csv")
    for csv in "${csv_files[@]}"; do
        if [[ ! -f "$SCRIPT_DIR/$csv" ]]; then
            error "CSV file not found: $SCRIPT_DIR/$csv"
            return 1
        fi
    done
    success "All CSV files present"

    # Check for existing data
    local existing_contacts
    existing_contacts=$(get_row_count "contacts" 2>/dev/null || echo "0")
    existing_contacts="${existing_contacts//[[:space:]]/}"

    if [[ "$existing_contacts" -gt 0 ]]; then
        warn "Database already has $existing_contacts contacts"
        echo ""
        echo "  1) Clear existing data and reload (TRUNCATE CASCADE)"
        echo "  2) Load data (skip duplicates)"
        echo "  3) Cancel"
        echo ""
        local data_choice
        read -rp "Choice [3]: " data_choice
        data_choice="${data_choice:-3}"

        case "$data_choice" in
            1)
                info "Clearing existing data..."
                case "$DB_TYPE" in
                    postgresql)
                        PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" <<-'EOSQL' 2>&1 | tee -a "$LOG_FILE"
                            TRUNCATE contact_lookup CASCADE;
                            TRUNCATE contact_contracts CASCADE;
                            TRUNCATE contact_phones CASCADE;
                            TRUNCATE contact_emails CASCADE;
                            TRUNCATE contact_addresses CASCADE;
                            TRUNCATE contact_pending_actions CASCADE;
                            TRUNCATE contact_alternate_ids CASCADE;
                            TRUNCATE contacts CASCADE;
                            TRUNCATE address_lines CASCADE;
                            TRUNCATE addresses CASCADE;
                            TRUNCATE contracts CASCADE;
                            SELECT 'Data cleared' AS status;
EOSQL
                        ;;
                    mysql)
                        mysql -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" <<-'EOSQL' 2>&1 | tee -a "$LOG_FILE"
                            SET FOREIGN_KEY_CHECKS = 0;
                            TRUNCATE TABLE contact_lookup;
                            TRUNCATE TABLE contact_contracts;
                            TRUNCATE TABLE contact_phones;
                            TRUNCATE TABLE contact_emails;
                            TRUNCATE TABLE contact_addresses;
                            TRUNCATE TABLE contact_pending_actions;
                            TRUNCATE TABLE contact_alternate_ids;
                            TRUNCATE TABLE contacts;
                            TRUNCATE TABLE address_lines;
                            TRUNCATE TABLE addresses;
                            TRUNCATE TABLE contracts;
                            SET FOREIGN_KEY_CHECKS = 1;
                            SELECT 'Data cleared' AS status;
EOSQL
                        ;;
                    sqlserver)
                        sqlcmd -S "$DB_HOST,$DB_PORT" -U "$DB_USER" -P "$DB_PASSWORD" -d "$DB_NAME" -Q "
                            DELETE FROM contact_lookup;
                            DELETE FROM contact_contracts;
                            DELETE FROM contact_phones;
                            DELETE FROM contact_emails;
                            DELETE FROM contact_addresses;
                            DELETE FROM contact_pending_actions;
                            DELETE FROM contact_alternate_ids;
                            DELETE FROM contacts;
                            DELETE FROM address_lines;
                            DELETE FROM addresses;
                            DELETE FROM contracts;
                            PRINT 'Data cleared';
                        " 2>&1 | tee -a "$LOG_FILE"
                        ;;
                esac
                success "Existing data cleared"
                ;;
            2)
                info "Loading data (duplicates will be skipped)..."
                ;;
            3)
                info "Cancelled"
                return 0
                ;;
            *)
                error "Invalid choice"
                return 1
                ;;
        esac
    fi

    # Run the loader script
    info "Loading test data (this may take several minutes for ~4.9M rows)..."
    echo ""

    local loader_script
    case "$DB_TYPE" in
        postgresql)
            loader_script="$SCRIPT_DIR/sql/load_postgresql.sql"
            info "Running PostgreSQL bulk loader..."
            # Run from the test-data directory so \copy paths resolve correctly
            (cd "$SCRIPT_DIR" && PGPASSWORD="$DB_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" \
                -f "$loader_script" 2>&1) | tee -a "$LOG_FILE"
            ;;
        mysql)
            loader_script="$SCRIPT_DIR/sql/load_mysql.sql"
            info "Running MySQL bulk loader..."
            (cd "$SCRIPT_DIR" && mysql --local-infile=1 -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASSWORD" "$DB_NAME" \
                < "$loader_script" 2>&1) | tee -a "$LOG_FILE"
            ;;
        sqlserver)
            loader_script="$SCRIPT_DIR/sql/load_sqlserver.sql"
            info "Running SQL Server bulk loader..."
            (cd "$SCRIPT_DIR" && sqlcmd -S "$DB_HOST,$DB_PORT" -U "$DB_USER" -P "$DB_PASSWORD" -d "$DB_NAME" \
                -i "$loader_script" 2>&1) | tee -a "$LOG_FILE"
            ;;
    esac

    local load_result=$?
    echo ""

    if [[ $load_result -eq 0 ]]; then
        success "Test data loaded successfully"
        echo ""
        info "Final row counts:"
        for table in contracts contacts addresses address_lines contact_addresses contact_emails contact_phones contact_contracts contact_lookup; do
            local count
            count=$(get_row_count "$table" 2>/dev/null || echo "?")
            printf "  %-30s %s\n" "$table" "${count//[[:space:]]/}"
        done
    else
        error "Data loading failed — check $LOG_FILE for details"
        return 1
    fi
}

# ---------------------------------------------------------------------------
# Option 5: Run gRPC Load Test
# ---------------------------------------------------------------------------
run_load_test() {
    echo ""
    echo -e "${BOLD}=== Run gRPC Load Test ===${NC}"
    echo ""

    check_tool java || return 1
    check_tool mvn || return 1

    # Check database has data
    if ensure_db_configured && check_db_tools; then
        local contact_count
        contact_count=$(get_row_count "contacts" 2>/dev/null || echo "0")
        contact_count="${contact_count//[[:space:]]/}"

        if [[ "$contact_count" -eq 0 ]]; then
            error "No contacts in database. Run option 4 to load test data first."
            return 1
        fi
        success "Database has $contact_count contacts"
    else
        warn "Cannot verify database — proceeding anyway"
    fi

    # Check gRPC service — prefer Istio ingress gateway for load-balanced access
    local grpc_host="localhost"
    local grpc_port="9001"

    # Detect Istio ingress gateway — verify actual connectivity, not just a process
    if (echo >/dev/tcp/localhost/"$ISTIO_GATEWAY_PORT") 2>/dev/null; then
        grpc_port="$ISTIO_GATEWAY_PORT"
        info "Istio ingress gateway reachable at localhost:$ISTIO_GATEWAY_PORT (load-balanced)"
    elif command -v kubectl &>/dev/null && kubectl get svc istio-ingressgateway -n istio-system &>/dev/null 2>&1; then
        warn "Istio ingress gateway exists but localhost:$ISTIO_GATEWAY_PORT is not reachable"
        echo "  To enable load-balanced access, run:"
        echo "    kubectl port-forward svc/istio-ingressgateway -n istio-system $ISTIO_GATEWAY_PORT:80 &"
        echo "  Falling back to localhost:9001 (single-pod, no load balancing)"
    fi

    read -rp "gRPC host [${grpc_host}]: " input
    grpc_host="${input:-$grpc_host}"
    read -rp "gRPC port [${grpc_port}]: " input
    grpc_port="${input:-$grpc_port}"

    info "Checking gRPC service at $grpc_host:$grpc_port..."
    if command -v grpcurl &>/dev/null; then
        if grpcurl -plaintext "$grpc_host:$grpc_port" list &>/dev/null; then
            success "gRPC service is reachable"
        else
            error "Cannot reach gRPC service at $grpc_host:$grpc_port"
            echo ""
            echo "Make sure the contact-api service is running and accessible."
            echo "  Istio gateway:  kubectl port-forward svc/istio-ingressgateway -n istio-system $ISTIO_GATEWAY_PORT:80 &"
            echo "  Direct pod:     kubectl port-forward service/contact-api 9001:9001 -n $K8S_NAMESPACE &"
            echo "  Docker:         docker compose -f test-data/docker-compose.yml ps"
            return 1
        fi
    else
        warn "grpcurl not available — skipping connectivity check"
    fi

    # Prompt for test parameters
    echo ""
    local concurrency burn_in duration
    read -rp "Concurrency (threads) [50]: " concurrency
    concurrency="${concurrency:-50}"
    read -rp "Burn-in period (seconds) [30]: " burn_in
    burn_in="${burn_in:-30}"
    read -rp "Test duration (seconds) [300]: " duration
    duration="${duration:-300}"

    # Compile and run
    info "Compiling load test..."
    (cd "$REPO_ROOT/contact" && mvn test-compile -pl contact-api -am -q) 2>&1 | tee -a "$LOG_FILE"

    if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
        error "Compilation failed"
        return 1
    fi
    success "Compilation successful"

    # Build classpath (include test-scoped dependencies for GrpcLoadTest)
    info "Resolving classpath..."
    local classpath
    classpath=$(cd "$REPO_ROOT/contact" && mvn -pl contact-api dependency:build-classpath -DincludeScope=test -Dmdep.outputFile=/dev/stdout -q 2>/dev/null)
    classpath="$REPO_ROOT/contact/contact-api/target/test-classes:$REPO_ROOT/contact/contact-api/target/classes:$classpath"

    echo ""
    info "Starting load test: --no-seed $concurrency $burn_in $duration (host=$grpc_host port=$grpc_port)"
    echo ""

    java -cp "$classpath" com.geastalt.contact.GrpcLoadTest \
        --no-seed "$concurrency" "$burn_in" "$duration" 8 200 "$grpc_host" "$grpc_port" \
        2>&1 | tee -a "$LOG_FILE"

    local test_result=${PIPESTATUS[0]}
    echo ""

    if [[ $test_result -eq 0 ]]; then
        success "Load test completed"
    else
        error "Load test failed with exit code $test_result"
        return 1
    fi
}

# ---------------------------------------------------------------------------
# Option 6: Full Setup
# ---------------------------------------------------------------------------
full_setup() {
    echo ""
    echo -e "${BOLD}=== Full Setup (Configure → Schema → Deploy → Load Data) ===${NC}"
    echo ""

    configure_database || { error "Database configuration failed"; return 1; }
    echo ""

    initialize_schema || { error "Schema initialization failed"; return 1; }
    echo ""

    deploy_services || { error "Service deployment failed"; return 1; }
    echo ""

    load_test_data || { error "Data loading failed"; return 1; }
    echo ""

    success "Full setup complete!"
    echo ""
    echo "Next steps:"
    echo "  - Run option 5 to execute the gRPC load test"
    echo "  - Or test manually: grpcurl -plaintext localhost:9001 list"
}

# ---------------------------------------------------------------------------
# Option 9: Evaluate Environment
# ---------------------------------------------------------------------------
evaluate_environment() {
    echo ""
    echo -e "${BOLD}=== Environment Evaluation ===${NC}"
    echo ""

    # --- Configuration ---
    echo -e "${BOLD}Configuration${NC}"
    if load_env 2>/dev/null && [[ -n "${DB_TYPE:-}" ]]; then
        echo -e "  .env file:        ${GREEN}found${NC}"
        echo "  Database type:    $DB_TYPE"
        echo "  Database host:    $DB_HOST:$DB_PORT"
        echo "  Database name:    $DB_NAME"
        echo "  Database user:    $DB_USER"
        echo "  Deploy mode:      ${DEPLOY_MODE:-not set}"
    else
        echo -e "  .env file:        ${YELLOW}not configured${NC} (run option 1)"
    fi
    echo ""

    # --- CLI Tools ---
    echo -e "${BOLD}CLI Tools${NC}"
    local tools=("psql" "mysql" "sqlcmd" "docker" "kubectl" "helm" "minikube" "grpcurl" "java" "mvn")
    for tool in "${tools[@]}"; do
        if command -v "$tool" &>/dev/null; then
            local ver
            case "$tool" in
                psql)     ver=$(psql --version 2>/dev/null | head -1) ;;
                mysql)    ver=$(mysql --version 2>/dev/null | head -1) ;;
                sqlcmd)   ver=$(sqlcmd --version 2>/dev/null | head -1) ;;
                docker)   ver=$(docker --version 2>/dev/null | head -1) ;;
                kubectl)  ver=$(kubectl version --client --short 2>/dev/null || kubectl version --client 2>/dev/null | head -1) ;;
                helm)     ver=$(helm version --short 2>/dev/null) ;;
                minikube) ver=$(minikube version --short 2>/dev/null) ;;
                grpcurl)  ver=$(grpcurl --version 2>&1 | head -1) ;;
                java)     ver=$(java -version 2>&1 | head -1) ;;
                mvn)      ver=$(mvn --version 2>/dev/null | head -1) ;;
                *)        ver="" ;;
            esac
            printf "  %-18s ${GREEN}%-10s${NC} %s\n" "$tool" "installed" "$ver"
        else
            printf "  %-18s ${YELLOW}%-10s${NC}\n" "$tool" "not found"
        fi
    done
    echo ""

    # --- CSV Test Data ---
    echo -e "${BOLD}Test Data Files${NC}"
    local csv_files=("contacts.csv" "addresses.csv" "companies_and_contracts.csv")
    for csv in "${csv_files[@]}"; do
        local path="$SCRIPT_DIR/$csv"
        if [[ -f "$path" ]]; then
            local size lines
            size=$(du -h "$path" | cut -f1)
            lines=$(wc -l < "$path")
            printf "  %-35s ${GREEN}present${NC}  %s  %s lines\n" "$csv" "$size" "$lines"
        else
            printf "  %-35s ${RED}missing${NC}\n" "$csv"
        fi
    done
    echo ""

    # --- Database ---
    echo -e "${BOLD}Database${NC}"

    # Configured connection check
    local db_connected=false
    if [[ -n "${DB_TYPE:-}" ]] && check_db_tools 2>/dev/null; then
        if test_db_connection 2>/dev/null; then
            db_connected=true
            echo -e "  Connection:       ${GREEN}OK${NC} ($DB_TYPE @ $DB_HOST:$DB_PORT/$DB_NAME)"

            # Check schema
            local schema_tables=("contacts" "addresses" "address_lines" "contact_addresses" "contact_emails"
                                 "contact_phones" "contracts" "contact_contracts" "contact_lookup"
                                 "contact_alternate_ids" "contact_pending_actions")
            local tables_found=0
            local tables_missing=0
            local missing_list=()
            for table in "${schema_tables[@]}"; do
                if check_table_exists "$table" 2>/dev/null; then
                    ((tables_found++))
                else
                    ((tables_missing++))
                    missing_list+=("$table")
                fi
            done

            if [[ $tables_missing -eq 0 ]]; then
                echo -e "  Schema:           ${GREEN}complete${NC} ($tables_found tables)"
            elif [[ $tables_found -eq 0 ]]; then
                echo -e "  Schema:           ${RED}not initialized${NC} (run option 2)"
            else
                echo -e "  Schema:           ${YELLOW}partial${NC} ($tables_found found, $tables_missing missing)"
                echo "  Missing tables:   ${missing_list[*]}"
            fi

            # Row counts
            if [[ $tables_found -gt 0 ]]; then
                echo ""
                echo "  Row counts:"
                for table in "${schema_tables[@]}"; do
                    if check_table_exists "$table" 2>/dev/null; then
                        local count
                        count=$(get_row_count "$table" 2>/dev/null || echo "?")
                        count="${count//[[:space:]]/}"
                        local status_color="$NC"
                        if [[ "$count" =~ ^[0-9]+$ ]] && [[ "$count" -gt 0 ]]; then
                            status_color="$GREEN"
                        fi
                        printf "    %-30s ${status_color}%s${NC}\n" "$table" "$count"
                    fi
                done
            fi
        else
            echo -e "  Connection:       ${RED}FAILED${NC} ($DB_TYPE @ $DB_HOST:$DB_PORT/$DB_NAME)"
        fi
    elif [[ -n "${DB_TYPE:-}" ]]; then
        echo -e "  Configured:       $DB_TYPE @ $DB_HOST:$DB_PORT/$DB_NAME"
        echo -e "  Connection:       ${YELLOW}cannot test — CLI tools missing${NC}"
    else
        echo -e "  Configured:       ${YELLOW}no .env file${NC} (run option 1)"
    fi

    # Detect running database and Kafka services (processes, ports, and Docker containers)
    echo ""
    echo "  Services detected:"
    local detected_any=false

    # Helper: check for a service via process, port, and Docker
    # Usage: detect_service "Label" "process_name" "default_port" "docker_grep_pattern"
    detect_service() {
        local label="$1" proc_name="$2" default_port="$3" docker_pattern="$4"
        local found=false
        local details=()

        # Check host process
        if [[ -n "$proc_name" ]]; then
            local proc
            proc=$(pgrep -xa "$proc_name" 2>/dev/null | grep -v "grep" | head -1 || true)
            if [[ -n "$proc" ]]; then
                found=true
                details+=("host process")
            fi
        fi

        # Check default port on localhost
        if [[ -n "$default_port" ]]; then
            if (echo >/dev/tcp/localhost/"$default_port") 2>/dev/null; then
                found=true
                details+=("port $default_port open")
            fi
        fi

        # Check Docker containers
        if command -v docker &>/dev/null && docker info &>/dev/null 2>&1; then
            local containers
            containers=$(docker ps --format '{{.Names}}\t{{.Image}}\t{{.Ports}}' 2>/dev/null | \
                grep -iE "$docker_pattern" || true)
            if [[ -n "$containers" ]]; then
                found=true
                while IFS=$'\t' read -r cname cimage cports; do
                    local port_info=""
                    if [[ -n "$cports" ]]; then
                        # Extract host-mapped ports (e.g., "0.0.0.0:3307->3306/tcp" → "3307")
                        port_info=$(echo "$cports" | grep -oE '0\.0\.0\.0:[0-9]+' | sed 's/0\.0\.0\.0://' | paste -sd, || true)
                    fi
                    local container_desc="docker: $cname ($cimage)"
                    if [[ -n "$port_info" ]]; then
                        container_desc="$container_desc → host port $port_info"
                    fi
                    details+=("$container_desc")
                done <<< "$containers"
            fi
        fi

        if $found; then
            detected_any=true
            printf "    %-20s ${GREEN}running${NC}\n" "$label"
            for detail in "${details[@]}"; do
                echo "      - $detail"
            done
        fi
    }

    detect_service "PostgreSQL" "postgres"  "5432" "postgres"
    detect_service "MySQL"      "mysqld"    "3306" "mysql|mariadb"
    detect_service "SQL Server" "sqlservr"  "1433" "sqlserver|mssql"
    detect_service "Kafka"      ""          "9092" "kafka"
    detect_service "Zookeeper"  ""          "2181" "zookeeper"

    if ! $detected_any; then
        echo -e "    ${YELLOW}none${NC}"
    fi
    echo ""

    # --- Kubernetes ---
    echo -e "${BOLD}Kubernetes${NC}"
    if command -v minikube &>/dev/null; then
        if minikube status &>/dev/null; then
            echo -e "  minikube:         ${GREEN}running${NC}"

            if command -v kubectl &>/dev/null; then
                echo "  Namespace:        $K8S_NAMESPACE"
                echo ""
                echo "  Deployments (namespace: $K8S_NAMESPACE):"
                local k8s_services=("contact-api" "async-generate-ffpe-id" "address" "kafka" "zookeeper")
                for svc in "${k8s_services[@]}"; do
                    local dep_status
                    dep_status=$(kubectl get deployment "$svc" -n "$K8S_NAMESPACE" -o jsonpath='{.status.readyReplicas}/{.status.replicas}' 2>/dev/null) || dep_status=""
                    if [[ -n "$dep_status" ]]; then
                        local ready
                        ready=$(echo "$dep_status" | cut -d/ -f1)
                        local desired
                        desired=$(echo "$dep_status" | cut -d/ -f2)
                        if [[ "$ready" == "$desired" ]] && [[ "$ready" -gt 0 ]]; then
                            printf "    %-25s ${GREEN}ready${NC} (%s replicas)\n" "$svc" "$dep_status"
                        else
                            printf "    %-25s ${YELLOW}not ready${NC} (%s replicas)\n" "$svc" "$dep_status"
                        fi
                    else
                        printf "    %-25s ${YELLOW}not deployed${NC}\n" "$svc"
                    fi
                done

                echo ""
                echo "  Secrets (namespace: $K8S_NAMESPACE):"
                local secrets=("external-fpe-key-secret" "async-generate-ffpe-id-secret" "address-secret")
                for secret in "${secrets[@]}"; do
                    if kubectl get secret "$secret" -n "$K8S_NAMESPACE" &>/dev/null; then
                        printf "    %-35s ${GREEN}present${NC}\n" "$secret"
                    else
                        printf "    %-35s ${YELLOW}missing${NC}\n" "$secret"
                    fi
                done

                echo ""
                echo "  Port-forwards:"
                local pf_pids
                pf_pids=$(pgrep -f "kubectl port-forward" 2>/dev/null || true)
                if [[ -n "$pf_pids" ]]; then
                    ps -p "$pf_pids" -o pid=,args= 2>/dev/null | while read -r line; do
                        echo "    PID $line"
                    done
                else
                    echo -e "    ${YELLOW}none active${NC}"
                fi

                # Istio status
                echo ""
                echo -e "  ${BOLD}Istio${NC}"
                if command -v istioctl &>/dev/null; then
                    printf "    %-25s ${GREEN}installed${NC} (%s)\n" "istioctl" "$(istioctl version --short 2>/dev/null | head -1)"
                else
                    printf "    %-25s ${YELLOW}not installed${NC}\n" "istioctl"
                fi

                if kubectl get namespace istio-system &>/dev/null; then
                    printf "    %-25s ${GREEN}present${NC}\n" "istio-system namespace"

                    # Check ingress gateway
                    # Check ingress gateway service exists
                    if kubectl get svc istio-ingressgateway -n istio-system &>/dev/null; then
                        printf "    %-25s ${GREEN}deployed${NC}\n" "ingress gateway"
                    else
                        printf "    %-25s ${YELLOW}not found${NC}\n" "ingress gateway"
                    fi

                    # Check port-forward to ingress gateway via actual connectivity
                    if (echo >/dev/tcp/localhost/"$ISTIO_GATEWAY_PORT") 2>/dev/null; then
                        printf "    %-25s ${GREEN}active${NC} (localhost:$ISTIO_GATEWAY_PORT)\n" "gateway port-forward"
                    else
                        printf "    %-25s ${YELLOW}not active${NC}\n" "gateway port-forward"
                        echo "      Run option 8 or: kubectl port-forward svc/istio-ingressgateway -n istio-system $ISTIO_GATEWAY_PORT:80 &"
                    fi
                else
                    printf "    %-25s ${YELLOW}not installed${NC}\n" "istio-system namespace"
                fi

                # Check sidecar injection label
                local injection_label
                injection_label=$(kubectl get namespace "$K8S_NAMESPACE" -o jsonpath='{.metadata.labels.istio-injection}' 2>/dev/null || true)
                if [[ "$injection_label" == "enabled" ]]; then
                    printf "    %-25s ${GREEN}enabled${NC} (namespace: $K8S_NAMESPACE)\n" "sidecar injection"
                else
                    printf "    %-25s ${YELLOW}not enabled${NC} (namespace: $K8S_NAMESPACE)\n" "sidecar injection"
                fi

                # Check pod sidecar status
                local pods_with_sidecar
                pods_with_sidecar=$(kubectl get pods -n "$K8S_NAMESPACE" -o jsonpath='{range .items[*]}{.metadata.name}{" "}{range .spec.containers[*]}{.name}{" "}{end}{"\n"}{end}' 2>/dev/null | grep -c "istio-proxy" || true)
                local total_pods
                total_pods=$(kubectl get pods -n "$K8S_NAMESPACE" --no-headers 2>/dev/null | wc -l | tr -d ' ')
                if [[ "$pods_with_sidecar" -gt 0 ]]; then
                    printf "    %-25s ${GREEN}%s/%s pods${NC}\n" "sidecar proxies" "$pods_with_sidecar" "$total_pods"
                elif [[ "$total_pods" -gt 0 ]]; then
                    printf "    %-25s ${YELLOW}0/%s pods${NC}\n" "sidecar proxies" "$total_pods"
                fi
            fi
        else
            echo -e "  minikube:         ${YELLOW}not running${NC}"
        fi
    else
        echo -e "  minikube:         ${YELLOW}not installed${NC}"
    fi
    echo ""

    # --- Docker ---
    echo -e "${BOLD}Docker${NC}"
    if command -v docker &>/dev/null; then
        if docker info &>/dev/null; then
            echo -e "  Docker daemon:    ${GREEN}running${NC}"

            # Scan for infrastructure containers (databases, Kafka)
            local infra_found=false

            # Databases
            echo ""
            echo "  Database containers:"
            local db_containers
            db_containers=$(docker ps --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}' 2>/dev/null | \
                grep -iE 'postgres|mysql|mariadb|sqlserver|mssql' || true)
            if [[ -n "$db_containers" ]]; then
                infra_found=true
                while IFS=$'\t' read -r cid cname cimage cstatus cports; do
                    local health_color="$GREEN"
                    echo "$cstatus" | grep -qi "unhealthy" && health_color="$RED"
                    echo "$cstatus" | grep -qi "starting\|restarting" && health_color="$YELLOW"
                    printf "    %-25s ${health_color}%s${NC}\n" "$cname" "$cstatus"
                    echo "      Image: $cimage"
                    if [[ -n "$cports" ]]; then
                        echo "      Ports: $cports"
                    fi
                done <<< "$db_containers"
            else
                echo -e "    ${YELLOW}none found${NC}"
            fi

            # Kafka / Zookeeper
            echo ""
            echo "  Kafka containers:"
            local kafka_containers
            kafka_containers=$(docker ps --format '{{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}' 2>/dev/null | \
                grep -iE 'kafka|zookeeper' || true)
            if [[ -n "$kafka_containers" ]]; then
                infra_found=true
                while IFS=$'\t' read -r cid cname cimage cstatus cports; do
                    local health_color="$GREEN"
                    echo "$cstatus" | grep -qi "unhealthy" && health_color="$RED"
                    echo "$cstatus" | grep -qi "starting\|restarting" && health_color="$YELLOW"
                    printf "    %-25s ${health_color}%s${NC}\n" "$cname" "$cstatus"
                    echo "      Image: $cimage"
                    if [[ -n "$cports" ]]; then
                        echo "      Ports: $cports"
                    fi
                done <<< "$kafka_containers"
            else
                echo -e "    ${YELLOW}none found${NC}"
            fi

            # Compose services (test-data)
            local compose_file="$SCRIPT_DIR/docker-compose.yml"
            if [[ -f "$compose_file" ]]; then
                local compose_containers
                compose_containers=$(docker compose -f "$compose_file" ps --format '{{.Name}} {{.Status}}' 2>/dev/null || true)
                if [[ -n "$compose_containers" ]]; then
                    echo ""
                    echo "  Compose services (test-data):"
                    while IFS= read -r line; do
                        local cname cstatus
                        cname=$(echo "$line" | awk '{print $1}')
                        cstatus=$(echo "$line" | cut -d' ' -f2-)
                        if echo "$cstatus" | grep -qi "up\|running"; then
                            printf "    %-25s ${GREEN}%s${NC}\n" "$cname" "$cstatus"
                        else
                            printf "    %-25s ${YELLOW}%s${NC}\n" "$cname" "$cstatus"
                        fi
                    done <<< "$compose_containers"
                fi
            fi
        else
            echo -e "  Docker daemon:    ${RED}not running${NC}"
        fi
    else
        echo -e "  Docker:           ${YELLOW}not installed${NC}"
    fi
    echo ""

    # --- gRPC Endpoint ---
    echo -e "${BOLD}gRPC Service${NC}"
    if command -v grpcurl &>/dev/null; then
        if grpcurl -plaintext localhost:9001 list &>/dev/null; then
            echo -e "  localhost:9001:   ${GREEN}reachable${NC}"
            local methods
            methods=$(grpcurl -plaintext localhost:9001 list 2>/dev/null || true)
            if [[ -n "$methods" ]]; then
                echo "  Services:"
                echo "$methods" | while IFS= read -r svc; do
                    echo "    $svc"
                done
            fi
        else
            echo -e "  localhost:9001:   ${YELLOW}not reachable${NC}"
        fi
    else
        # Fallback: try a raw TCP check
        if (echo >/dev/tcp/localhost/9001) 2>/dev/null; then
            echo -e "  localhost:9001:   ${GREEN}port open${NC} (install grpcurl for full check)"
        else
            echo -e "  localhost:9001:   ${YELLOW}not reachable${NC}"
        fi
    fi
    echo ""
}

# ---------------------------------------------------------------------------
# Main menu
# ---------------------------------------------------------------------------
show_menu() {
    echo ""
    echo -e "${BOLD}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BOLD}║          Geastalt Test Environment Setup                     ║${NC}"
    echo -e "${BOLD}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo ""

    # Show current config if available
    if load_env 2>/dev/null && [[ -n "${DB_TYPE:-}" ]]; then
        echo -e "  ${CYAN}Current config:${NC} $DB_TYPE @ $DB_HOST:$DB_PORT/$DB_NAME (user: $DB_USER)"
        if [[ -n "${DEPLOY_MODE:-}" ]]; then
            echo -e "  ${CYAN}Deploy mode:${NC}    $DEPLOY_MODE"
        fi
        echo ""
    fi

    echo "  1) Configure Database"
    echo "  2) Initialize Database Schema"
    echo "  3) Deploy Services"
    echo "  4) Load Test Data"
    echo "  5) Run gRPC Load Test"
    echo "  6) Full Setup (1-4)"
    echo "  7) Create Kubernetes Secrets"
    echo "  8) Install/Configure Istio"
    echo "  9) Evaluate Environment"
    echo "  0) Exit"
    echo ""
}

main() {
    # Initialize log
    echo "=== Setup started at $(date) ===" >> "$LOG_FILE"

    while true; do
        show_menu
        local choice
        read -rp "Select option: " choice

        case "$choice" in
            1) configure_database || true ;;
            2) initialize_schema || true ;;
            3) deploy_services || true ;;
            4) load_test_data || true ;;
            5) run_load_test || true ;;
            6) full_setup || true ;;
            7) create_k8s_secrets || true ;;
            8) install_configure_istio || true ;;
            9) evaluate_environment || true ;;
            0)
                echo ""
                info "Goodbye!"
                exit 0
                ;;
            q)
                echo ""
                info "Goodbye!"
                exit 0
                ;;
            *)
                error "Invalid option: $choice"
                ;;
        esac
    done
}

main "$@"
